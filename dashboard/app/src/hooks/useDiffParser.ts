/**
 * useDiffParser Hook
 *
 * Parses unified diff format and returns structured data for rendering.
 * Supports standard unified diff format as generated by git diff.
 *
 * @module hooks/useDiffParser
 * @author ECO-Lambda | DFO 4.0 Epic 3 Sprint 3.2
 * @date 2026-01-02
 * @task DFO-202-EPIC21
 */

import { useMemo } from 'react';
import { parsePatch, StructuredPatchHunk } from 'diff';

/**
 * Type of line in a diff
 * - 'added': Line was added in the new version (+)
 * - 'deleted': Line was deleted from the old version (-)
 * - 'unchanged': Line exists in both versions ( )
 * - 'context': Context or informational line
 */
export type LineType = 'added' | 'deleted' | 'unchanged' | 'context';

/**
 * Represents a single line in a diff
 *
 * @property {LineType} type - Type of change for this line
 * @property {string} content - Actual content of the line (without +/- prefix)
 * @property {number | null} oldLineNumber - Line number in old file (null for added lines)
 * @property {number | null} newLineNumber - Line number in new file (null for deleted lines)
 * @property {number} lineNumber - Sequential line number within the hunk for rendering
 *
 * @example
 * ```typescript
 * {
 *   type: 'added',
 *   content: 'console.log("new");',
 *   oldLineNumber: null,
 *   newLineNumber: 5,
 *   lineNumber: 3
 * }
 * ```
 */
export interface DiffLine {
  type: LineType;
  content: string;
  oldLineNumber: number | null;
  newLineNumber: number | null;
  lineNumber: number;
}

/**
 * Represents a hunk (continuous block of changes) in a diff
 *
 * @property {string} id - Unique identifier for the hunk (e.g., "hunk-0")
 * @property {string} header - Hunk header line (e.g., "@@ -1,3 +1,4 @@")
 * @property {number} oldStart - Starting line number in old file
 * @property {number} oldLines - Number of lines from old file in this hunk
 * @property {number} newStart - Starting line number in new file
 * @property {number} newLines - Number of lines from new file in this hunk
 * @property {DiffLine[]} lines - Array of diff lines in this hunk
 *
 * @example
 * ```typescript
 * {
 *   id: "hunk-0",
 *   header: "@@ -1,3 +1,4 @@",
 *   oldStart: 1,
 *   oldLines: 3,
 *   newStart: 1,
 *   newLines: 4,
 *   lines: [...]
 * }
 * ```
 */
export interface DiffHunk {
  id: string;
  header: string;
  oldStart: number;
  oldLines: number;
  newStart: number;
  newLines: number;
  lines: DiffLine[];
}

/**
 * Complete parsed diff structure for a single file
 *
 * @property {string | null} oldFileName - Original filename (null if not available)
 * @property {string | null} newFileName - New filename (null if not available)
 * @property {DiffHunk[]} hunks - Array of hunks representing blocks of changes
 * @property {number} totalAdditions - Total number of lines added across all hunks
 * @property {number} totalDeletions - Total number of lines deleted across all hunks
 * @property {string | null} language - Detected programming language based on file extension
 *
 * @example
 * ```typescript
 * {
 *   oldFileName: "test.js",
 *   newFileName: "test.js",
 *   hunks: [{ id: "hunk-0", ... }],
 *   totalAdditions: 2,
 *   totalDeletions: 1,
 *   language: "javascript"
 * }
 * ```
 */
export interface ParsedDiff {
  oldFileName: string | null;
  newFileName: string | null;
  hunks: DiffHunk[];
  totalAdditions: number;
  totalDeletions: number;
  language: string | null;
}

/**
 * Detects programming language from file extension
 */
function detectLanguage(fileName: string | null): string | null {
  if (!fileName) return null;

  const ext = fileName.split('.').pop()?.toLowerCase();
  const languageMap: Record<string, string> = {
    js: 'javascript',
    jsx: 'javascript',
    ts: 'typescript',
    tsx: 'typescript',
    py: 'python',
    rb: 'ruby',
    java: 'java',
    cpp: 'cpp',
    c: 'c',
    cs: 'csharp',
    go: 'go',
    rs: 'rust',
    php: 'php',
    html: 'html',
    css: 'css',
    scss: 'scss',
    json: 'json',
    md: 'markdown',
    sql: 'sql',
    sh: 'bash',
    yml: 'yaml',
    yaml: 'yaml',
  };

  return ext ? languageMap[ext] || null : null;
}

/**
 * React hook that parses unified diff format into structured data for rendering
 *
 * This hook takes a standard unified diff string (as generated by `git diff`) and
 * converts it into a structured format suitable for visualization in React components.
 * The result is memoized and only recomputed when the diffString changes.
 *
 * Supports:
 * - Multiple hunks per file
 * - Line-by-line type classification (added/deleted/unchanged/context)
 * - Automatic language detection from file extensions (20+ languages)
 * - Old and new line number tracking
 * - Total addition/deletion counts
 *
 * @param {string} diffString - Unified diff format string (e.g., from `git diff`)
 * @returns {ParsedDiff} Structured diff data with hunks, lines, and metadata
 *
 * @example
 * ```typescript
 * const MyDiffComponent = () => {
 *   const diffString = `diff --git a/test.js b/test.js
 * --- a/test.js
 * +++ b/test.js
 * @@ -1,3 +1,4 @@
 *  function hello() {
 * -  console.log('old');
 * +  console.log('new');
 * +  return true;
 *  }`;
 *
 *   const parsedDiff = useDiffParser(diffString);
 *
 *   return (
 *     <div>
 *       <h3>{parsedDiff.newFileName}</h3>
 *       <p>+{parsedDiff.totalAdditions} -{parsedDiff.totalDeletions}</p>
 *       {parsedDiff.hunks.map(hunk => (
 *         <div key={hunk.id}>
 *           <div>{hunk.header}</div>
 *           {hunk.lines.map(line => (
 *             <div key={line.lineNumber} className={line.type}>
 *               {line.content}
 *             </div>
 *           ))}
 *         </div>
 *       ))}
 *     </div>
 *   );
 * };
 * ```
 *
 * @example
 * Empty diff handling:
 * ```typescript
 * const emptyDiff = useDiffParser('');
 * // Returns: { oldFileName: null, newFileName: null, hunks: [], totalAdditions: 0, totalDeletions: 0, language: null }
 * ```
 *
 * @see {@link https://git-scm.com/docs/diff-format|Git Diff Format Documentation}
 */
export function useDiffParser(diffString: string): ParsedDiff {
  return useMemo(() => {
    if (!diffString || diffString.trim() === '') {
      return {
        oldFileName: null,
        newFileName: null,
        hunks: [],
        totalAdditions: 0,
        totalDeletions: 0,
        language: null,
      };
    }

    try {
      const parsed = parsePatch(diffString);
      if (parsed.length === 0) {
        return {
          oldFileName: null,
          newFileName: null,
          hunks: [],
          totalAdditions: 0,
          totalDeletions: 0,
          language: null,
        };
      }

      const file = parsed[0];
      let totalAdditions = 0;
      let totalDeletions = 0;

      const hunks: DiffHunk[] = file.hunks.map((hunk: StructuredPatchHunk, hunkIndex: number) => {
        const lines: DiffLine[] = [];
        let oldLineNum = hunk.oldStart;
        let newLineNum = hunk.newStart;
        let lineNumber = 0;

        hunk.lines.forEach((line: string) => {
          lineNumber++;
          const firstChar = line.charAt(0);

          if (firstChar === '+') {
            totalAdditions++;
            lines.push({
              type: 'added',
              content: line.slice(1),
              oldLineNumber: null,
              newLineNumber: newLineNum,
              lineNumber,
            });
            newLineNum++;
          } else if (firstChar === '-') {
            totalDeletions++;
            lines.push({
              type: 'deleted',
              content: line.slice(1),
              oldLineNumber: oldLineNum,
              newLineNumber: null,
              lineNumber,
            });
            oldLineNum++;
          } else if (firstChar === ' ') {
            lines.push({
              type: 'unchanged',
              content: line.slice(1),
              oldLineNumber: oldLineNum,
              newLineNumber: newLineNum,
              lineNumber,
            });
            oldLineNum++;
            newLineNum++;
          } else {
            // Context or header line
            lines.push({
              type: 'context',
              content: line,
              oldLineNumber: null,
              newLineNumber: null,
              lineNumber,
            });
          }
        });

        return {
          id: `hunk-${hunkIndex}`,
          header: `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@`,
          oldStart: hunk.oldStart,
          oldLines: hunk.oldLines,
          newStart: hunk.newStart,
          newLines: hunk.newLines,
          lines,
        };
      });

      const newFileName = file.newFileName || null;
      const language = detectLanguage(newFileName);

      return {
        oldFileName: file.oldFileName || null,
        newFileName,
        hunks,
        totalAdditions,
        totalDeletions,
        language,
      };
    } catch (error) {
      console.error('Failed to parse diff:', error);
      return {
        oldFileName: null,
        newFileName: null,
        hunks: [],
        totalAdditions: 0,
        totalDeletions: 0,
        language: null,
      };
    }
  }, [diffString]);
}
